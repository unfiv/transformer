# Transformer (CPU Mesh Skinning)
Консольное приложение для CPU skinning'а OBJ-меша на основе:
- весов/индексов костей на вершину (до 4 влияний);
- inverse bind pose матриц;
- матриц новой позы.

## Структура исходников
- `src/app` — оркестрация сценария выполнения приложения.
- `src/io` — парсинг входных данных и запись выходных файлов (OBJ/JSON/stats).
- `src/skinning` — CPU skinning.
- `src/core` — базовые типы, математика, профилировщик.

## Сборка
Проект собирается через `CMakePresets.json`.

### Linux/macOS (Ninja)
```bash
cmake --preset release
cmake --build --preset build
```

Для других типов сборки:
- Debug: `cmake --preset debug && cmake --build --preset build-debug`
- RelWithDebInfo: `cmake --preset relwithdeb && cmake --build --preset build-relwithdeb`

### Windows (новое устройство / MSVC + Ninja)
```powershell
cmake --preset windows-msvc-release
cmake --build --preset build-win-release
```

Для отладки на Windows используйте `windows-msvc-debug` + `build-win-debug`.

## Запуск
```bash
./out/build/release/transformer --mesh <meshFile.obj> --bones-weights <boneWeightFile.json> --inverse-bind-pose <inverseBindPoseFile.json> --new-pose <newPoseFile.json> --output <resultFile.obj> --stats <statsFile.json> [--bench <N>]
```

Типовой рабочий запуск:
```bash
--mesh "assets/test_mesh.obj" --bones-weights "assets/bone_weight.json" --inverse-bind-pose "assets/inverse_bind_pose.json" --new-pose "assets/new_pose.json" --output "result_mesh.obj" --stats stats.json
```

## Формат `boneWeightFile.json`
```json
{
  "vertices": [
    {
      "bone_indices": [0, 4, 9, 15],
      "weights": [0.6, 0.2, 0.2, 0.0]
    }
  ]
}
```

## Формат pose json (`inverseBindPoseFile.json` и `newPoseFile.json`)
```json
{
  "bones": [
    {
      "matrix": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
  ]
}
```
Матрица передаётся в **column-major** порядке.

## Профилирование
В `statsFile.json` записывается время в микросекундах (с точностью до 3 знаков после запятой):
- каждого модуля (чтение mesh/weights/poses, skinning, запись mesh);
- суммарное время `total` (на верхнем уровне).

Если передан `--bench <N>`, операция `cpu_skinning` выполняется `N` раз, а в `statsFile.json` дополнительно пишется сводка: `min/max/mean/median/stddev` по этим `N` прогонам.

# Окружение
Проект использует CMake/CMakePresets/clang-format, чтобы сохранять единый стиль кодирования, а также обеспечивать единообразность и простоту сборки/запуска на разных платформах. Также обеспечивается консистентность тулчейна, чтобы избежать проблем с различными версиями компилятора, линкера и т.д.

# Стресс-тестирование
Организован отдельный стенд для запуска тестов: cmake target `stress`.
Теперь это **один** запуск утилиты с параметром `--bench 100` (число настраивается через `STRESS_RUNS`), без внешнего цикла в CMake.

Агрегированная статистика берётся из `statsFile.json` приложения и включает:
- `mean`, `median`, `stddev`, `min`, `max` (в микросекундах) для `cpu_skinning` по `N` прогонам.

## Ошибки CLI
- При неизвестном аргументе, пропущенном значении флага или отсутствии обязательных флагов приложение завершится с кодом `1` и выведет usage.
- `--bench` принимает только положительное целое число.

# Оптимизация
Особенности текущего тестового стенда, которые следует учитывать при анализе результатов оптимизации:
- Низкополигональный меш и малое количество костей: имеем небольшой набор данных, которые могут очень хорошо помещаться в кеш практически любой архитектуры (в частности нижнего уровня). На реальных моделях данных и операций работы с кешем будет гораздо больше. Рекомендуется тестировать на нескольих типах моделей.
- Тестирование и результаты приводятся для определённого железа, чтобы оценить алгоритмы требуется большая выборка стендов.
- Работа ведётся с одной моделью, что опять же делает алгоритмы более кеш-дружественными. В реальных играх чаще всего анимируется множество объектов, в связи с чем чаще необходимо переключать кеш-контекст.
- Мы игнорируем небольшую погрешность, возникающую при парсинге дробных значений.
- Оптимизацию по многопоточности и SIMD мы делаем не кросс-платформенной исключительно для упрощения.
- На финальной стадии после интеграции SIMD была попытка перевести вычисления в многопоточную среду, однако результаты стали хуже. Это связано с тем, что накладные расходы на многопоточноть перекрыли профит. При большем количестве данных ситуация могла бы быть иной.

Ниже представлены итерации оптимизации и результаты стресс-тестирования:
- 1.0 Базовая версия с честными последовательными вычислениями:
"bench": {
    "runs": 10000,
    "min_microseconds": 78.700,
    "max_microseconds": 413.900,
    "mean_microseconds": 137.157,
    "median_microseconds": 138.500,
    "stddev_microseconds": 14.750
  }
- 1.1 Версия с оптимизированными лэйаутами данных (объединили всё, что можно было для горячего цикла, переход SOA -> AOS), тем не менее результат остался практически таким же, но в теории на других архитектурах может быть буст:
"bench": {
    "runs": 10000,
    "min_microseconds": 135.100,
    "max_microseconds": 294.400,
    "mean_microseconds": 137.542,
    "median_microseconds": 135.700,
    "stddev_microseconds": 7.487
  }
- 1.2 Версия с прекомпилированной матрицей для скиннинга, мы сократили количество перемножений с 4400 до 33 (количество костей), убрали избыточные операции. Одновременно должны были "раскрыться" предыдущие оптимизации по лэйауту:  
"bench": {
    "runs": 10000,
    "min_microseconds": 47.400,
    "max_microseconds": 637.400,
    "mean_microseconds": 49.582,
    "median_microseconds": 47.800,
    "stddev_microseconds": 12.631
  }
- 1.3 Мы убедились на этапе загрузки, что сумма весов костей всегда 1, и на основании этой информации убрали лишние операции (не работаем с компонентой W, избегаем нормализации и деления координат). Второй важный момент, что в "горячем цикле" мы убираем бранчинг: подготавливаем данные так, что каждая вершина всегда имеет все 4 кости для веса, и в скиннинге всегда работаем со всеми четырьмя матрицами (когда работаем с "фейковыми", то там нули). Процессору проще "перемолоть" последовательно пустые данные, чем делать проверки, ветвления и сбрасывать контейнер инструкций из-за неудачных предсказаний переходов:
"bench": {
    "runs": 10000,
    "min_microseconds": 27.100,
    "max_microseconds": 113.400,
    "mean_microseconds": 29.923,
    "median_microseconds": 27.700,
    "stddev_microseconds": 4.475
  }
- 1.4 Мы применили технику Single Instruction Multiple Data во время перемножения координат вектора на предвычисленную скиннинг матрицу, на предыдущем этапе мы уже разложили последовательность операций (покомпонентное умножение и сложнение) логически, а здесь мы лишь технически делаем их за одну инструкцию с помощью специального регистра:
"bench": {
    "runs": 10000,
    "min_microseconds": 13.800,
    "max_microseconds": 493.100,
    "mean_microseconds": 17.044,
    "median_microseconds": 14.200,
    "stddev_microseconds": 8.457
  }